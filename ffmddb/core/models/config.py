"""
Configuration file (.ffmddbrc):

my_log_files:
    collections:
        - name: logs
          path: ./logs
        - name: participants
          path: ./participants
    indices:
        - name: log_tag
          from: ['logs', 'metadata:tag']
        - name: participants_logs
          from: ['participants', 'name:']
          to: ['logs', 'metadata:participants']
"""

from ffmddb.core.models.document import (
    Collection,
    CollectionField,
)
from ffmddb.core.models.field import Field
from ffmddb.core.models.index import (
    CrossCollectionIndex,
    SingleCollectionIndex,
)


class Configuration:
    """Stores database configuration read from a file or the user."""

    def __init__(self, name, collections, indices):
        self.name = name
        self.collections = collections
        self.indices = indices

    def marshal(self):
        pass

    @classmethod
    def from_object(cls, config_obj):
        """Parses a configuration object (as generated by loading a yaml
        configuration file) into an internal object used by the database
        """
        if len(config_obj) != 1:
            raise cls.MalformedConfiguration(
                'config may only contain one root-level key')
        name, config_obj = config_obj.popitem()
        if 'collections' not in config_obj or 'indices' not in config_obj:
            raise cls.MalformedConfiguration(
                'config must contain `collections` and `indices` keys (even '
                'if they are empty lists)')
        if type(config_obj['collections']) not in [list, tuple]:
            raise cls.MalformedConfiguration(
                '`collections` must be a list (even if it is empty)')
        if type(config_obj['indices']) not in [list, tuple]:
            raise cls.MalformedConfiguration(
                '`indices` must be a list (even if it is empty)')
        collections = {}
        for collection in config_obj['collections']:
            cname = collection.get('name', None)
            cpath = collection.get('path', None)
            if cname is None or cpath is None:
                raise cls.MalformedConfiguration(
                    'collection `name` and `path` are required')
            collections[cname] = Collection(cname, cpath)
        indices = {}
        for index in config_obj['indices']:
            cname = index.get('name', None)
            cfrom = index.get('from', None)
            cto = index.get('to', None)
            if cname is None or cfrom is None:
                raise cls.MalformedConfiguration(
                    'index `name` and `from` fields are required')
            cfrom_collection = collections.get(cfrom[0], None)
            if cfrom_collection is None:
                raise cls.MalformedConfiguration(
                    'indicies must specify a valid collection by name in the '
                    'from field')
            cfrom_field = Field(cfrom[1])
            cf_from = CollectionField(cfrom_collection, cfrom_field)
            if cto is None:
                indices[cname] = SingleCollectionIndex(cname, cf_from)
            else:
                cto_collection = collections.get(cto[0], None)
                if cto_collection is None:
                    raise cls.MalformedConfiguration(
                        'indicies must specify a valid collection by name in '
                        'the to field')
                cto_field = Field(cto[1])
                cf_to = CollectionField(cto_collection, cto_field)
                indices[cname] = CrossCollectionIndex(cname, cf_from, cf_to)
        return Configuration(name, collections, indices)

    class MalformedConfiguration(Exception):
        pass
