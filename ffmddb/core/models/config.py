import yaml

from ffmddb.core.models.document import (
    Collection,
    CollectionField,
)
from ffmddb.core.models.field import Field
from ffmddb.core.models.index import (
    CrossCollectionIndex,
    SingleCollectionIndex,
)


DEFAULT_OPTIONS = {
    'fence': ['---+', '---+'],
    'indices_location': '.ffmddb_idx',
    'multiple_metadata': False,
}

CONFIG_VERSION = 1


class Configuration:
    """Stores database configuration read from a file or the user."""

    def __init__(self, name, collections, indices, options):
        """TODO"""
        self.name = name
        self.collections = collections
        self.indices = indices
        self.options = options

    def write(self, filename):
        """TODO"""
        config_str = self.marshal()
        with open(filename, 'w') as f:
            f.write(config_str)

    def close(self, filename):
        """TODO"""
        if filename:
            self.write(filename)

    def marshal(self):
        """marshals the configuration object back to YAML"""
        marshaled_config = {
            self.name: {
                'collections': [c.marshal() for c in
                                self.collections.values()],
                'indices': [i.marshal() for i in self.indices.values()],
            }
        }
        marshaled_config[self.name].update(self.options)
        return yaml.safe_dump(marshaled_config)

    @classmethod
    def from_object(cls, config_obj):
        """Parses a configuration object (as generated by loading a yaml
        configuration file) into an internal object used by the database
        """

        # Ensure there's only one key.
        if len(config_obj) != 1:
            raise cls.MalformedConfiguration(
                'config may only contain one root-level key')
        name, config_obj = config_obj.popitem()

        # Ensure that collections and indices keys exist and are lists.
        if 'collections' not in config_obj or 'indices' not in config_obj:
            raise cls.MalformedConfiguration(
                'config must contain `collections` and `indices` keys (even '
                'if they are empty lists)')
        if type(config_obj['collections']) not in [list, tuple]:
            raise cls.MalformedConfiguration(
                '`collections` must be a list (even if it is empty)')
        if type(config_obj['indices']) not in [list, tuple]:
            raise cls.MalformedConfiguration(
                '`indices` must be a list (even if it is empty)')

        # Fetch all collections.
        collections = {}
        for collection in config_obj['collections']:
            cname = collection.get('name', None)
            cpath = collection.get('path', None)

            # Ensure name and path are specified
            if cname is None or cpath is None:
                raise cls.MalformedConfiguration(
                    'collection `name` and `path` are required')
            collections[cname] = Collection(cname, cpath)
        del config_obj['collections']

        # Fetch and parse all indices
        indices = {}
        for index in config_obj['indices']:
            cname = index.get('name', None)
            cfrom = index.get('from', None)
            cto = index.get('to', None)

            # Ensure an index name and a from field are specified.
            if cname is None or cfrom is None:
                raise cls.MalformedConfiguration(
                    'index `name` and `from` fields are required')

            # Ensure that the referenced collection exists
            cfrom_collection = collections.get(cfrom[0], None)
            if cfrom_collection is None:
                raise cls.MalformedConfiguration(
                    'indicies must specify a valid collection by name in the '
                    'from field')
            cfrom_field = Field(cfrom[1])
            cf_from = CollectionField(cfrom_collection, cfrom_field)

            # Build a single or cross collection index depending on the
            # presence of a `to` collection field.
            if cto is None:
                indices[cname] = SingleCollectionIndex(cname, cf_from)
            else:
                cto_collection = collections.get(cto[0], None)
                if cto_collection is None:
                    raise cls.MalformedConfiguration(
                        'indicies must specify a valid collection by name in '
                        'the to field')
                cto_field = Field(cto[1])
                cf_to = CollectionField(cto_collection, cto_field)
                indices[cname] = CrossCollectionIndex(cname, cf_from, cf_to)
        del config_obj['indices']

        # Grab additional configuration values, supplying defaults if needed.
        options = DEFAULT_OPTIONS.copy()
        options.update(config_obj)

        return Configuration(name, collections, indices, options)

    class MalformedConfiguration(Exception):
        """TODO"""
        pass
